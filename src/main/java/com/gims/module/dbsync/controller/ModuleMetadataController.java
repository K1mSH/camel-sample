package com.gims.module.dbsync.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

/**
 * 모듈 메타데이터 API 컨트롤러
 *
 * 관리 시스템에서 이 모듈의 Source/Target DB 테이블 및 컬럼 정보를 조회할 수 있습니다.
 */
@Slf4j
@RestController
@RequestMapping("/api/module/metadata")
public class ModuleMetadataController {

    private final DataSource sourceDataSource;
    private final DataSource targetDataSource;

    // @RequiredArgsConstructor와 @Qualifier를 함께 사용하면 Qualifier가 적용되지 않음
    // 생성자를 직접 작성하여 @Qualifier 적용
    public ModuleMetadataController(
            @Qualifier("sourceDataSource") DataSource sourceDataSource,
            @Qualifier("targetDataSource") DataSource targetDataSource) {
        this.sourceDataSource = sourceDataSource;
        this.targetDataSource = targetDataSource;
    }

    /**
     * Source DB 테이블 목록 조회
     */
    @GetMapping("/tables/source")
    public ResponseEntity<Map<String, Object>> getSourceTables() {
        return getTableList(sourceDataSource, "source");
    }

    /**
     * Target DB 테이블 목록 조회
     */
    @GetMapping("/tables/target")
    public ResponseEntity<Map<String, Object>> getTargetTables() {
        return getTableList(targetDataSource, "target");
    }

    /**
     * Source DB 테이블 컬럼 목록 조회
     */
    @GetMapping("/columns/source")
    public ResponseEntity<Map<String, Object>> getSourceColumns(@RequestParam String tableName) {
        return getColumnList(sourceDataSource, tableName, "source");
    }

    /**
     * Target DB 테이블 컬럼 목록 조회
     */
    @GetMapping("/columns/target")
    public ResponseEntity<Map<String, Object>> getTargetColumns(@RequestParam String tableName) {
        return getColumnList(targetDataSource, tableName, "target");
    }

    /**
     * 양쪽 DB 테이블/컬럼 비교 정보 조회
     */
    @GetMapping("/compare")
    public ResponseEntity<Map<String, Object>> getCompareInfo(
            @RequestParam String sourceTable,
            @RequestParam String targetTable,
            @RequestParam(required = false, defaultValue = "true") boolean excludeAutoGenerated) {

        Map<String, Object> result = new HashMap<>();
        try {
            List<Map<String, Object>> sourceColumns = getColumnsFromDb(sourceDataSource, sourceTable);
            List<Map<String, Object>> targetColumns = getColumnsFromDb(targetDataSource, targetTable);

            // 자동생성 컬럼 제외
            if (excludeAutoGenerated) {
                targetColumns = filterAutoGeneratedColumns(targetColumns);
            }

            result.put("success", true);
            result.put("sourceColumns", sourceColumns);
            result.put("targetColumns", targetColumns);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("컬럼 비교 조회 오류", e);
            result.put("success", false);
            result.put("message", e.getMessage());
            return ResponseEntity.internalServerError().body(result);
        }
    }

    /**
     * DB 정보 조회 (연결 테스트용)
     */
    @GetMapping("/info")
    public ResponseEntity<Map<String, Object>> getDbInfo() {
        Map<String, Object> result = new HashMap<>();
        try {
            Map<String, Object> sourceInfo = getDbConnectionInfo(sourceDataSource, "source");
            Map<String, Object> targetInfo = getDbConnectionInfo(targetDataSource, "target");

            result.put("success", true);
            result.put("source", sourceInfo);
            result.put("target", targetInfo);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("DB 정보 조회 오류", e);
            result.put("success", false);
            result.put("message", e.getMessage());
            return ResponseEntity.internalServerError().body(result);
        }
    }

    // ==================== Private Methods ====================

    private ResponseEntity<Map<String, Object>> getTableList(DataSource dataSource, String dbType) {
        Map<String, Object> result = new HashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            DatabaseMetaData metaData = conn.getMetaData();
            String schema = getDefaultSchema(metaData);

            List<Map<String, Object>> tables = new ArrayList<>();

            try (ResultSet rs = metaData.getTables(null, schema, "%", new String[]{"TABLE"})) {
                while (rs.next()) {
                    Map<String, Object> table = new HashMap<>();
                    table.put("tableName", rs.getString("TABLE_NAME"));
                    table.put("tableType", rs.getString("TABLE_TYPE"));
                    table.put("schema", rs.getString("TABLE_SCHEM"));
                    table.put("remarks", rs.getString("REMARKS"));
                    tables.add(table);
                }
            }

            result.put("success", true);
            result.put("dbType", dbType);
            result.put("schema", schema);
            result.put("data", tables);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("테이블 목록 조회 오류: dbType={}", dbType, e);
            result.put("success", false);
            result.put("message", e.getMessage());
            return ResponseEntity.internalServerError().body(result);
        }
    }

    private ResponseEntity<Map<String, Object>> getColumnList(DataSource dataSource, String tableName, String dbType) {
        Map<String, Object> result = new HashMap<>();
        try {
            List<Map<String, Object>> columns = getColumnsFromDb(dataSource, tableName);
            result.put("success", true);
            result.put("dbType", dbType);
            result.put("tableName", tableName);
            result.put("data", columns);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("컬럼 목록 조회 오류: dbType={}, tableName={}", dbType, tableName, e);
            result.put("success", false);
            result.put("message", e.getMessage());
            return ResponseEntity.internalServerError().body(result);
        }
    }

    private List<Map<String, Object>> getColumnsFromDb(DataSource dataSource, String tableName) throws SQLException {
        List<Map<String, Object>> columns = new ArrayList<>();
        Set<String> pkColumns = new HashSet<>();

        try (Connection conn = dataSource.getConnection()) {
            DatabaseMetaData metaData = conn.getMetaData();
            String schema = getDefaultSchema(metaData);

            // PK 컬럼 조회
            try (ResultSet pkRs = metaData.getPrimaryKeys(null, schema, tableName)) {
                while (pkRs.next()) {
                    pkColumns.add(pkRs.getString("COLUMN_NAME"));
                }
            }

            // 컬럼 정보 조회
            try (ResultSet rs = metaData.getColumns(null, schema, tableName, "%")) {
                while (rs.next()) {
                    Map<String, Object> column = new HashMap<>();
                    String columnName = rs.getString("COLUMN_NAME");
                    String dataType = rs.getString("TYPE_NAME");
                    int columnSize = rs.getInt("COLUMN_SIZE");
                    int decimalDigits = rs.getInt("DECIMAL_DIGITS");
                    boolean nullable = rs.getInt("NULLABLE") == DatabaseMetaData.columnNullable;
                    String remarks = rs.getString("REMARKS");
                    int ordinal = rs.getInt("ORDINAL_POSITION");

                    column.put("columnName", columnName);
                    column.put("dataType", dataType);
                    column.put("columnLength", columnSize);
                    column.put("columnScale", decimalDigits);
                    column.put("nullable", nullable);
                    column.put("primaryKey", pkColumns.contains(columnName));
                    column.put("columnComment", remarks);
                    column.put("ordinalPosition", ordinal);
                    column.put("autoGenerated", isAutoGeneratedColumn(columnName, pkColumns.contains(columnName)));
                    column.put("typeGroup", getTypeGroup(dataType));

                    columns.add(column);
                }
            }
        }

        // ordinalPosition 기준 정렬
        columns.sort(Comparator.comparingInt(c -> (Integer) c.getOrDefault("ordinalPosition", 999)));
        return columns;
    }

    private String getDefaultSchema(DatabaseMetaData metaData) throws SQLException {
        String dbProduct = metaData.getDatabaseProductName().toLowerCase();
        if (dbProduct.contains("postgresql")) {
            return "public";
        } else if (dbProduct.contains("oracle")) {
            return metaData.getUserName();
        } else if (dbProduct.contains("mysql")) {
            return metaData.getConnection().getCatalog();
        }
        return null;
    }

    private boolean isAutoGeneratedColumn(String columnName, boolean isPrimaryKey) {
        if (columnName == null) return false;
        String upper = columnName.toUpperCase();

        // PK이면서 _ID로 끝나면 자동생성
        if (isPrimaryKey && upper.endsWith("_ID")) return true;

        // 일반적인 자동생성 컬럼 패턴
        return upper.contains("REG_DT") || upper.contains("UPD_DT")
                || upper.contains("CREATED_AT") || upper.contains("UPDATED_AT")
                || upper.contains("CREATE_DATE") || upper.contains("UPDATE_DATE")
                || upper.contains("INSERT_DT") || upper.contains("MODIFY_DT")
                || upper.equals("CREATED_BY") || upper.equals("UPDATED_BY")
                || upper.equals("REG_ID") || upper.equals("UPD_ID")
                || upper.contains("_SEQ") || upper.contains("SEQUENCE");
    }

    private String getTypeGroup(String dataType) {
        if (dataType == null) return "OTHER";
        String upper = dataType.toUpperCase();

        if (upper.contains("VARCHAR") || upper.contains("CHAR") || upper.contains("TEXT")
                || upper.contains("CLOB") || upper.contains("STRING")) {
            return "STRING";
        } else if (upper.contains("INT") || upper.contains("NUMBER") || upper.contains("NUMERIC")
                || upper.contains("DECIMAL") || upper.contains("FLOAT") || upper.contains("DOUBLE")
                || upper.contains("SERIAL") || upper.contains("REAL")) {
            return "NUMBER";
        } else if (upper.contains("DATE") || upper.contains("TIME") || upper.contains("TIMESTAMP")) {
            return "DATE";
        } else if (upper.contains("BOOL") || upper.contains("BIT")) {
            return "BOOLEAN";
        } else if (upper.contains("BLOB") || upper.contains("BINARY") || upper.contains("BYTEA")) {
            return "BINARY";
        }
        return "OTHER";
    }

    private List<Map<String, Object>> filterAutoGeneratedColumns(List<Map<String, Object>> columns) {
        List<Map<String, Object>> filtered = new ArrayList<>();
        for (Map<String, Object> col : columns) {
            Boolean autoGenerated = (Boolean) col.getOrDefault("autoGenerated", false);
            if (!autoGenerated) {
                filtered.add(col);
            }
        }
        return filtered;
    }

    private Map<String, Object> getDbConnectionInfo(DataSource dataSource, String dbType) throws SQLException {
        Map<String, Object> info = new HashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            DatabaseMetaData metaData = conn.getMetaData();
            info.put("dbType", dbType);
            info.put("databaseProductName", metaData.getDatabaseProductName());
            info.put("databaseProductVersion", metaData.getDatabaseProductVersion());
            info.put("driverName", metaData.getDriverName());
            info.put("url", metaData.getURL());
            info.put("userName", metaData.getUserName());
            info.put("schema", getDefaultSchema(metaData));
            info.put("connected", true);
        } catch (Exception e) {
            info.put("dbType", dbType);
            info.put("connected", false);
            info.put("error", e.getMessage());
        }
        return info;
    }
}
